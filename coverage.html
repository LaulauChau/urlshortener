
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/axellelanca/urlshortener/cmd/cli/create.go (0.0%)</option>
				
				<option value="file1">github.com/axellelanca/urlshortener/cmd/cli/migrate.go (0.0%)</option>
				
				<option value="file2">github.com/axellelanca/urlshortener/cmd/cli/stats.go (0.0%)</option>
				
				<option value="file3">github.com/axellelanca/urlshortener/cmd/root.go (0.0%)</option>
				
				<option value="file4">github.com/axellelanca/urlshortener/cmd/server/server.go (0.0%)</option>
				
				<option value="file5">github.com/axellelanca/urlshortener/internal/api/handlers.go (79.5%)</option>
				
				<option value="file6">github.com/axellelanca/urlshortener/internal/config/config.go (0.0%)</option>
				
				<option value="file7">github.com/axellelanca/urlshortener/internal/monitor/url_monitor.go (0.0%)</option>
				
				<option value="file8">github.com/axellelanca/urlshortener/internal/repository/click_repository.go (0.0%)</option>
				
				<option value="file9">github.com/axellelanca/urlshortener/internal/repository/link_repository.go (0.0%)</option>
				
				<option value="file10">github.com/axellelanca/urlshortener/internal/services/click_service.go (0.0%)</option>
				
				<option value="file11">github.com/axellelanca/urlshortener/internal/services/link_service.go (0.0%)</option>
				
				<option value="file12">github.com/axellelanca/urlshortener/internal/services/mocks/mock_repositories.go (0.0%)</option>
				
				<option value="file13">github.com/axellelanca/urlshortener/internal/workers/click_workers.go (0.0%)</option>
				
				<option value="file14">github.com/axellelanca/urlshortener/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "fmt"
        "log"
        "net/url"
        "os"

        "github.com/axellelanca/urlshortener/cmd"
        "github.com/axellelanca/urlshortener/internal/repository"
        "github.com/axellelanca/urlshortener/internal/services"
        "github.com/spf13/cobra"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

var longURLFlag string

var CreateCmd = &amp;cobra.Command{
        Use:   "create",
        Short: "Crée une URL courte à partir d'une URL longue.",
        Long: `Cette commande raccourcit une URL longue fournie et affiche le code court généré.

Exemple:
  url-shortener create --url="https://www.google.com/search?q=go+lang"`,
        Run: func(cobraCmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if longURLFlag == "" </span><span class="cov0" title="0">{
                        fmt.Println("Erreur: Le flag --url est requis")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">_, err := url.ParseRequestURI(longURLFlag)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Erreur: URL invalide: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">cfg := cmd.Cfg
                if cfg == nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Configuration non chargée")
                }</span>

                <span class="cov0" title="0">db, err := gorm.Open(sqlite.Open(cfg.Database.Name), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de la connexion à la base de données: %v", err)
                }</span>

                <span class="cov0" title="0">sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de l'obtention de la base de données SQL sous-jacente: %v", err)
                }</span>

                <span class="cov0" title="0">defer sqlDB.Close()

                linkRepo := repository.NewLinkRepository(db)
                clickRepo := repository.NewClickRepository(db)
                linkService := services.NewLinkService(linkRepo, clickRepo)

                link, err := linkService.CreateLink(longURLFlag)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Erreur lors de la création du lien: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fullShortURL := fmt.Sprintf("%s/%s", cfg.Server.BaseURL, link.ShortCode)
                fmt.Printf("URL courte créée avec succès:\n")
                fmt.Printf("Code: %s\n", link.ShortCode)
                fmt.Printf("URL complète: %s\n", fullShortURL)</span>
        },
}

func init() <span class="cov0" title="0">{
        CreateCmd.Flags().StringVar(&amp;longURLFlag, "url", "", "URL longue à raccourcir")

        CreateCmd.MarkFlagRequired("url")
        cmd.RootCmd.AddCommand(CreateCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "fmt"
        "log"

        "github.com/axellelanca/urlshortener/cmd"
        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/spf13/cobra"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

var MigrateCmd = &amp;cobra.Command{
        Use:   "migrate",
        Short: "Exécute les migrations de la base de données pour créer ou mettre à jour les tables.",
        Long: `Cette commande se connecte à la base de données configurée (SQLite)
et exécute les migrations automatiques de GORM pour créer les tables 'links' et 'clicks'
basées sur les modèles Go.`,
        Run: func(cobraCmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg := cmd.Cfg
                if cfg == nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Configuration non chargée")
                }</span>

                <span class="cov0" title="0">db, err := gorm.Open(sqlite.Open(cfg.Database.Name), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de la connexion à la base de données: %v", err)
                }</span>

                <span class="cov0" title="0">sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de l'obtention de la base de données SQL sous-jacente: %v", err)
                }</span>
                <span class="cov0" title="0">defer sqlDB.Close()

                if err := db.AutoMigrate(&amp;models.Link{}, &amp;models.Click{}); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec des migrations: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Migrations de la base de données exécutées avec succès.")</span>
        },
}

func init() <span class="cov0" title="0">{
        cmd.RootCmd.AddCommand(MigrateCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "errors"
        "fmt"
        "log"
        "os"

        "github.com/axellelanca/urlshortener/cmd"
        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/repository"
        "github.com/axellelanca/urlshortener/internal/services"
        "github.com/spf13/cobra"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

var shortCodeFlag string

var StatsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Affiche les statistiques (nombre de clics) pour un lien court.",
        Long: `Cette commande permet de récupérer et d'afficher le nombre total de clics
pour une URL courte spécifique en utilisant son code.

Exemple:
  url-shortener stats --code="xyz123"`,
        Run: func(cobraCmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if shortCodeFlag == "" </span><span class="cov0" title="0">{
                        fmt.Println("Erreur: Le flag --code est requis")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">cfg := cmd.Cfg
                if cfg == nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Configuration non chargée")
                }</span>

                <span class="cov0" title="0">db, err := gorm.Open(sqlite.Open(cfg.Database.Name), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de la connexion à la base de données: %v", err)
                }</span>

                <span class="cov0" title="0">sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de l'obtention de la base de données SQL sous-jacente: %v", err)
                }</span>

                <span class="cov0" title="0">defer sqlDB.Close()

                linkRepo := repository.NewLinkRepository(db)
                clickRepo := repository.NewClickRepository(db)
                linkService := services.NewLinkService(linkRepo, clickRepo)

                link, totalClicks, err := linkService.GetLinkStats(shortCodeFlag)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, models.ErrLinkNotFound) </span><span class="cov0" title="0">{
                                fmt.Printf("Erreur: Aucun lien trouvé avec le code '%s'\n", shortCodeFlag)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Erreur lors de la récupération des statistiques: %v", err)
                        os.Exit(1)</span>
                }

                <span class="cov0" title="0">fmt.Printf("Statistiques pour le code court: %s\n", link.ShortCode)
                fmt.Printf("URL longue: %s\n", link.LongURL)
                fmt.Printf("Total de clics: %d\n", totalClicks)</span>
        },
}

func init() <span class="cov0" title="0">{
        StatsCmd.Flags().StringVar(&amp;shortCodeFlag, "code", "", "Code court pour lequel afficher les statistiques")
        StatsCmd.MarkFlagRequired("code")
        cmd.RootCmd.AddCommand(StatsCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "log"
        "os"

        "github.com/axellelanca/urlshortener/internal/config"
        "github.com/spf13/cobra"
)

var Cfg *config.Config

var RootCmd = &amp;cobra.Command{
        Use:   "url-shortener",
        Short: "Un service de raccourcissement d'URLs avec API REST et CLI",
        Long: `'url-shortener' est une application complète pour gérer des URLs courtes.
Elle inclut un serveur API pour le raccourcissement et la redirection,
ainsi qu'une interface en ligne de commande pour l'administration.

Utilisez 'url-shortener [command] --help' pour plus d'informations sur une commande.`,
}

func Execute() <span class="cov0" title="0">{
        if err := RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erreur lors de l'exécution de la commande: %v\n", err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)
}</span>

func initConfig() <span class="cov0" title="0">{
        var err error
        Cfg, err = config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Attention: Problème lors du chargement de la configuration: %v. Utilisation des valeurs par défaut.", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package server

import (
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/axellelanca/urlshortener/cmd"
        "github.com/axellelanca/urlshortener/internal/api"
        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/monitor"
        "github.com/axellelanca/urlshortener/internal/repository"
        "github.com/axellelanca/urlshortener/internal/services"
        "github.com/axellelanca/urlshortener/internal/workers"
        "github.com/gin-gonic/gin"
        "github.com/spf13/cobra"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)


var RunServerCmd = &amp;cobra.Command{
        Use:   "run-server",
        Short: "Lance le serveur API de raccourcissement d'URLs et les processus de fond.",
        Long: `Cette commande initialise la base de données, configure les APIs,
démarre les workers asynchrones pour les clics et le moniteur d'URLs,
puis lance le serveur HTTP.`,
        Run: func(cobraCmd *cobra.Command, args []string) <span class="cov0" title="0">{

                cfg := cmd.Cfg
                if cfg == nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Configuration non chargée")
                }</span>


                <span class="cov0" title="0">db, err := gorm.Open(sqlite.Open(cfg.Database.Name), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("FATAL: Échec de la connexion à la base de données: %v", err)
                }</span>

                <span class="cov0" title="0">linkRepo := repository.NewLinkRepository(db)
                clickRepo := repository.NewClickRepository(db)

                log.Println("Repositories initialisés.")

                linkService := services.NewLinkService(linkRepo, clickRepo)
                _ = services.NewClickService(clickRepo)

        
                log.Println("Services métiers initialisés.")


                clickEventsChannel := make(chan models.ClickEvent, cfg.Analytics.BufferSize)
                workers.StartClickWorkers(cfg.Analytics.WorkerCount, clickEventsChannel, clickRepo)

                log.Printf("Channel d'événements de clic initialisé avec un buffer de %d. %d worker(s) de clics démarré(s).",
                        cfg.Analytics.BufferSize, cfg.Analytics.WorkerCount)

                monitorInterval := time.Duration(cfg.Monitor.IntervalMinutes) * time.Minute
                urlMonitor := monitor.NewUrlMonitor(linkRepo, monitorInterval)
                go urlMonitor.Start()
                log.Printf("Moniteur d'URLs démarré avec un intervalle de %v.", monitorInterval)


                router := gin.Default()
                api.SetupRoutes(router, linkService, cfg.Analytics.BufferSize, cfg.Server.BaseURL)


                api.ClickEventsChannel = clickEventsChannel


                log.Println("Routes API configurées.")

        
                serverAddr := fmt.Sprintf(":%d", cfg.Server.Port)
                srv := &amp;http.Server{
                        Addr:    serverAddr,
                        Handler: router,
                }

                go func() </span><span class="cov0" title="0">{
                        log.Printf("Serveur HTTP démarré sur le port %d", cfg.Server.Port)
                        log.Printf("URL de base: %s", cfg.Server.BaseURL)
                        if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                log.Fatalf("FATAL: Échec du démarrage du serveur HTTP: %v", err)
                        }</span>
                }()
        

                <span class="cov0" title="0">quit := make(chan os.Signal, 1)
                signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) 

                &lt;-quit
                log.Println("Signal d'arrêt reçu. Arrêt du serveur...")
                
                log.Println("Arrêt en cours... Donnez un peu de temps aux workers pour finir.")
                time.Sleep(5 * time.Second)

                log.Println("Serveur arrêté proprement.")</span>
        },
}

func init() <span class="cov0" title="0">{
        cmd.RootCmd.AddCommand(RunServerCmd)
}</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "errors"
        "log"
        "net/http"
        "time"

        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/services"
        "github.com/gin-gonic/gin"
)

var ClickEventsChannel chan models.ClickEvent

func SetupRoutes(router *gin.Engine, linkService *services.LinkService, bufferSize int, baseURL string) <span class="cov10" title="5">{
        if ClickEventsChannel == nil </span><span class="cov1" title="1">{
                ClickEventsChannel = make(chan models.ClickEvent, bufferSize)
        }</span>

        <span class="cov10" title="5">router.GET("/health", HealthCheckHandler)

        apiV1 := router.Group("/api/v1")
        </span><span class="cov10" title="5">{
                apiV1.POST("/links", CreateShortLinkHandler(linkService, baseURL))
                apiV1.GET("/links/:shortCode/stats", GetLinkStatsHandler(linkService))
        }</span>

        <span class="cov10" title="5">router.GET("/:shortCode", RedirectHandler(linkService))</span>
}

func HealthCheckHandler(c *gin.Context) <span class="cov1" title="1">{
        c.JSON(http.StatusOK, gin.H{"status": "ok"})
}</span>

type CreateLinkRequest struct {
        LongURL string `json:"long_url" binding:"required,url"`
}

func CreateShortLinkHandler(linkService *services.LinkService, baseURL string) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov8" title="4">{
                var req CreateLinkRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov7" title="3">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov1" title="1">link, err := linkService.CreateLink(req.LongURL)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{
                        "short_code":     link.ShortCode,
                        "long_url":       link.LongURL,
                        "full_short_url": baseURL + "/" + link.ShortCode,
                })</span>
        }
}

func RedirectHandler(linkService *services.LinkService) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov7" title="3">{
                shortCode := c.Param("shortCode")

                link, err := linkService.GetLinkByShortCode(shortCode)
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, models.ErrLinkNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": "Link not found"})
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("Error retrieving link for %s: %v", shortCode, err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
                        return</span>
                }

                <span class="cov4" title="2">clickEvent := models.ClickEvent{
                        LinkID:    link.ID,
                        Timestamp: time.Now(),
                        UserAgent: c.GetHeader("User-Agent"),
                        IPAddress: c.ClientIP(),
                }

                select </span>{
                case ClickEventsChannel &lt;- clickEvent:<span class="cov4" title="2"></span>
                default:<span class="cov0" title="0">
                        log.Printf("Warning: ClickEventsChannel is full, dropping click event for %s.", shortCode)</span>
                }

                <span class="cov4" title="2">c.Redirect(http.StatusFound, link.LongURL)</span>
        }
}

func GetLinkStatsHandler(linkService *services.LinkService) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov4" title="2">{
                shortCode := c.Param("shortCode")

                link, totalClicks, err := linkService.GetLinkStats(shortCode)
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, models.ErrLinkNotFound) </span><span class="cov1" title="1">{
                                c.JSON(http.StatusNotFound, gin.H{"error": "Link not found"})
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("Error retrieving stats for %s: %v", shortCode, err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
                        return</span>
                }

                <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                        "short_code":   link.ShortCode,
                        "long_url":     link.LongURL,
                        "total_clicks": totalClicks,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "log"

        "github.com/spf13/viper"
)

type Config struct {
        Server    ServerConfig    `mapstructure:"server"`
        Database  DatabaseConfig  `mapstructure:"database"`
        Analytics AnalyticsConfig `mapstructure:"analytics"`
        Monitor   MonitorConfig   `mapstructure:"monitor"`
}

type ServerConfig struct {
        Port    int    `mapstructure:"port"`
        BaseURL string `mapstructure:"base_url"`
}

type DatabaseConfig struct {
        Name string `mapstructure:"name"`
}

type AnalyticsConfig struct {
        BufferSize  int `mapstructure:"buffer_size"`
        WorkerCount int `mapstructure:"worker_count"`
}

type MonitorConfig struct {
        IntervalMinutes int `mapstructure:"interval_minutes"`
}

func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        viper.AddConfigPath("./configs")
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")

        viper.SetDefault("server.port", 8080)
        viper.SetDefault("server.base_url", "http://localhost:8080")
        viper.SetDefault("database.name", "url_shortener.db")
        viper.SetDefault("analytics.buffer_size", 1000)
        viper.SetDefault("analytics.worker_count", 5)
        viper.SetDefault("monitor.interval_minutes", 5)

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                        log.Println("Fichier de configuration non trouvé, utilisation des valeurs par défaut")
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("erreur lors de la lecture du fichier de configuration: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var cfg Config
        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lors du démappage de la configuration: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Configuration loaded: Server Port=%d, DB Name=%s, Analytics Buffer=%d, Monitor Interval=%dmin",
                cfg.Server.Port, cfg.Database.Name, cfg.Analytics.BufferSize, cfg.Monitor.IntervalMinutes)

        return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package monitor

import (
        "log"
        "net/http"
        "sync"
        "time"

        _ "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/repository"
)

type UrlMonitor struct {
        linkRepo    repository.LinkRepository
        interval    time.Duration
        knownStates map[uint]bool
        mu          sync.Mutex
}

func NewUrlMonitor(linkRepo repository.LinkRepository, interval time.Duration) *UrlMonitor <span class="cov0" title="0">{
        return &amp;UrlMonitor{
                linkRepo:    linkRepo,
                interval:    interval,
                knownStates: make(map[uint]bool),
        }
}</span>

func (m *UrlMonitor) Start() <span class="cov0" title="0">{
        log.Printf("[MONITOR] Démarrage du moniteur d'URLs avec un intervalle de %v...", m.interval)
        ticker := time.NewTicker(m.interval)
        defer ticker.Stop()

        m.checkUrls()

        for range ticker.C </span><span class="cov0" title="0">{
                m.checkUrls()
        }</span>
}

func (m *UrlMonitor) checkUrls() <span class="cov0" title="0">{
        log.Println("[MONITOR] Lancement de la vérification de l'état des URLs...")

        links, err := m.linkRepo.GetAllLinks()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[MONITOR] ERREUR lors de la récupération des liens pour la surveillance : %v", err)
                return
        }</span>

        <span class="cov0" title="0">for _, link := range links </span><span class="cov0" title="0">{
                currentState := m.isUrlAccessible(link.LongURL)

                m.mu.Lock()
                previousState, exists := m.knownStates[link.ID]
                m.knownStates[link.ID] = currentState
                m.mu.Unlock()

                if !exists </span><span class="cov0" title="0">{
                        log.Printf("[MONITOR] État initial pour le lien %s (%s) : %s",
                                link.ShortCode, link.LongURL, formatState(currentState))
                        continue</span>
                }

                <span class="cov0" title="0">if previousState != currentState </span><span class="cov0" title="0">{
                        log.Printf("[NOTIFICATION] Le lien %s (%s) est passé de %s à %s !",
                                link.ShortCode, link.LongURL, formatState(previousState), formatState(currentState))
                }</span>

        }
        <span class="cov0" title="0">log.Println("[MONITOR] Vérification de l'état des URLs terminée.")</span>
}

func (m *UrlMonitor) isUrlAccessible(url string) bool <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: 5 * time.Second,
        }

        resp, err := client.Head(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[MONITOR] Erreur d'accès à l'URL '%s': %v", url, err)
                return false
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400</span>
}

func formatState(accessible bool) string <span class="cov0" title="0">{
        if accessible </span><span class="cov0" title="0">{
                return "ACCESSIBLE"
        }</span>
        <span class="cov0" title="0">return "INACCESSIBLE"</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "fmt"

        "github.com/axellelanca/urlshortener/internal/models"
        "gorm.io/gorm"
)


type ClickRepository interface {
        CreateClick(click *models.Click) error
        GetClicksByLinkID(linkID uint) ([]models.Click, error)
        CountClicksByLinkID(linkID uint) (int, error)
}

type GormClickRepository struct {
        db *gorm.DB
}

func NewClickRepository(db *gorm.DB) *GormClickRepository <span class="cov0" title="0">{
        return &amp;GormClickRepository{db: db}
}</span>

func (r *GormClickRepository) CreateClick(click *models.Click) error <span class="cov0" title="0">{
        if err := r.db.Create(click).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create click: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *GormClickRepository) GetClicksByLinkID(linkID uint) ([]models.Click, error) <span class="cov0" title="0">{
        var clicks []models.Click
        if err := r.db.Where("link_id = ?", linkID).Find(&amp;clicks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get clicks: %w", err)
        }</span>
        <span class="cov0" title="0">return clicks, nil</span>
}

func (r *GormClickRepository) CountClicksByLinkID(linkID uint) (int, error) <span class="cov0" title="0">{
        var count int64
        if err := r.db.Model(&amp;models.Click{}).Where("link_id = ?", linkID).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count clicks: %w", err)
        }</span>
        <span class="cov0" title="0">return int(count), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "fmt"

        "github.com/axellelanca/urlshortener/internal/models"
        "gorm.io/gorm"
)

type LinkRepository interface {
        CreateLink(link *models.Link) error
        GetLinkByShortCode(shortCode string) (*models.Link, error)
        GetAllLinks() ([]models.Link, error)
        CountClicksByLinkID(linkID uint) (int, error)
}

type GormLinkRepository struct {
        db *gorm.DB
}

func NewLinkRepository(db *gorm.DB) *GormLinkRepository <span class="cov0" title="0">{
        return &amp;GormLinkRepository{db: db}
}</span>

func (r *GormLinkRepository) CreateLink(link *models.Link) error <span class="cov0" title="0">{
        if err := r.db.Create(link).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create link: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *GormLinkRepository) GetLinkByShortCode(shortCode string) (*models.Link, error) <span class="cov0" title="0">{
        var link models.Link
        if err := r.db.Where("short_code = ?", shortCode).First(&amp;link).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;link, nil</span>
}

func (r *GormLinkRepository) GetAllLinks() ([]models.Link, error) <span class="cov0" title="0">{
        var links []models.Link
        if err := r.db.Find(&amp;links).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all links: %w", err)
        }</span>
        <span class="cov0" title="0">return links, nil</span>
}

func (r *GormLinkRepository) CountClicksByLinkID(linkID uint) (int, error) <span class="cov0" title="0">{
        var count int64
        if err := r.db.Model(&amp;models.Click{}).Where("link_id = ?", linkID).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count clicks: %w", err)
        }</span>
        <span class="cov0" title="0">return int(count), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "fmt"

        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/repository"
)

// ClickService fournit des méthodes pour la logique métier des clics.
type ClickService struct {
        clickRepo repository.ClickRepository
}

// NewClickService crée et retourne une nouvelle instance de ClickService.
// C'est la fonction recommandée pour obtenir un service, assurant que toutes ses dépendances sont injectées.
func NewClickService(clickRepo repository.ClickRepository) *ClickService <span class="cov0" title="0">{
        return &amp;ClickService{
                clickRepo: clickRepo,
        }
}</span>

// ProcessClickEvent traite un événement de clic et le persiste en base de données.
func (s *ClickService) ProcessClickEvent(event models.ClickEvent) error <span class="cov0" title="0">{
        click := &amp;models.Click{
                LinkID:    event.LinkID,
                Timestamp: event.Timestamp,
                UserAgent: event.UserAgent,
                IPAddress: event.IPAddress,
        }

        if err := s.clickRepo.CreateClick(click); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create click: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetClicksByLinkID récupère tous les clics pour un lien donné.
func (s *ClickService) GetClicksByLinkID(linkID uint) ([]models.Click, error) <span class="cov0" title="0">{
        clicks, err := s.clickRepo.GetClicksByLinkID(linkID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get clicks: %w", err)
        }</span>
        <span class="cov0" title="0">return clicks, nil</span>
}

// CountClicksByLinkID compte le nombre de clics pour un lien donné.
func (s *ClickService) CountClicksByLinkID(linkID uint) (int, error) <span class="cov0" title="0">{
        count, err := s.clickRepo.CountClicksByLinkID(linkID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count clicks: %w", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "crypto/rand"
        "errors"
        "fmt"
        "log"
        "math/big"
        "time"

        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/repository"
        "gorm.io/gorm"
)

const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

type LinkService struct {
        linkRepo  repository.LinkRepository
        clickRepo repository.ClickRepository
}

func NewLinkService(linkRepo repository.LinkRepository, clickRepo repository.ClickRepository) *LinkService <span class="cov0" title="0">{
        return &amp;LinkService{
                linkRepo:  linkRepo,
                clickRepo: clickRepo,
        }
}</span>

func (s *LinkService) GenerateShortCode(length int) (string, error) <span class="cov0" title="0">{
        result := make([]byte, length)
        for i := range result </span><span class="cov0" title="0">{
                num, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to generate random number: %w", err)
                }</span>
                <span class="cov0" title="0">result[i] = charset[num.Int64()]</span>
        }
        <span class="cov0" title="0">return string(result), nil</span>
}

func (s *LinkService) CreateLink(longURL string) (*models.Link, error) <span class="cov0" title="0">{
        var shortCode string
        const maxRetries = 5

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                code, err := s.GenerateShortCode(6)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate short code: %w", err)
                }</span>
                <span class="cov0" title="0">_, err = s.linkRepo.GetLinkByShortCode(code)

                if err != nil </span><span class="cov0" title="0">{
        
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                shortCode = code 
                                break</span>            
                        }

                        <span class="cov0" title="0">return nil, fmt.Errorf("database error checking short code uniqueness: %w", err)</span>
                }
                <span class="cov0" title="0">log.Printf("Short code '%s' already exists, retrying generation (%d/%d)...", code, i+1, maxRetries)</span>
        }

        <span class="cov0" title="0">if shortCode == "" </span><span class="cov0" title="0">{
                return nil, models.ErrShortCodeGenerationFailed
        }</span>

        <span class="cov0" title="0">link := &amp;models.Link{
                ShortCode: shortCode,
                LongURL:   longURL,
                CreatedAt: time.Now(),
        }

        if err := s.linkRepo.CreateLink(link); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create link in database: %w", err)
        }</span>

        <span class="cov0" title="0">return link, nil</span>
}


func (s *LinkService) GetLinkByShortCode(shortCode string) (*models.Link, error) <span class="cov0" title="0">{
        link, err := s.linkRepo.GetLinkByShortCode(shortCode)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, models.ErrLinkNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("database error retrieving link: %w", err)</span>
        }

        <span class="cov0" title="0">return link, nil</span>
}


func (s *LinkService) GetLinkStats(shortCode string) (*models.Link, int, error) <span class="cov0" title="0">{
        link, err := s.GetLinkByShortCode(shortCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">totalClicks, err := s.clickRepo.CountClicksByLinkID(link.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count clicks: %w", err)
        }</span>

        <span class="cov0" title="0">return link, totalClicks, nil</span>
}

</pre>
		
		<pre class="file" id="file12" style="display: none">package mocks

import (
        "errors"

        "github.com/axellelanca/urlshortener/internal/models"
        "gorm.io/gorm"
)

type MockLinkRepository struct {
        links   map[string]*models.Link
        nextID  uint
        shouldFail bool
}

func NewMockLinkRepository() *MockLinkRepository <span class="cov0" title="0">{
        return &amp;MockLinkRepository{
                links:  make(map[string]*models.Link),
                nextID: 1,
        }
}</span>

func (m *MockLinkRepository) SetShouldFail(shouldFail bool) <span class="cov0" title="0">{
        m.shouldFail = shouldFail
}</span>

func (m *MockLinkRepository) CreateLink(link *models.Link) error <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">if link.ID == 0 </span><span class="cov0" title="0">{
                link.ID = m.nextID
                m.nextID++
        }</span>
        
        <span class="cov0" title="0">m.links[link.ShortCode] = link
        return nil</span>
}

func (m *MockLinkRepository) GetLinkByShortCode(shortCode string) (*models.Link, error) <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return nil, errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">link, exists := m.links[shortCode]
        if !exists </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>
        
        <span class="cov0" title="0">return link, nil</span>
}

func (m *MockLinkRepository) GetAllLinks() ([]models.Link, error) <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return nil, errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">var allLinks []models.Link
        for _, link := range m.links </span><span class="cov0" title="0">{
                allLinks = append(allLinks, *link)
        }</span>
        
        <span class="cov0" title="0">return allLinks, nil</span>
}

func (m *MockLinkRepository) CountClicksByLinkID(linkID uint) (int, error) <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return 0, errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">return 5, nil</span>
}

type MockClickRepository struct {
        clicks     map[uint][]models.Click
        shouldFail bool
}

func NewMockClickRepository() *MockClickRepository <span class="cov0" title="0">{
        return &amp;MockClickRepository{
                clicks: make(map[uint][]models.Click),
        }
}</span>

func (m *MockClickRepository) SetShouldFail(shouldFail bool) <span class="cov0" title="0">{
        m.shouldFail = shouldFail
}</span>

func (m *MockClickRepository) CreateClick(click *models.Click) error <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">m.clicks[click.LinkID] = append(m.clicks[click.LinkID], *click)
        return nil</span>
}

func (m *MockClickRepository) GetClicksByLinkID(linkID uint) ([]models.Click, error) <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return nil, errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">clicks, exists := m.clicks[linkID]
        if !exists </span><span class="cov0" title="0">{
                return []models.Click{}, nil
        }</span>
        
        <span class="cov0" title="0">return clicks, nil</span>
}

func (m *MockClickRepository) CountClicksByLinkID(linkID uint) (int, error) <span class="cov0" title="0">{
        if m.shouldFail </span><span class="cov0" title="0">{
                return 0, errors.New("mock database error")
        }</span>
        
        <span class="cov0" title="0">clicks, exists := m.clicks[linkID]
        if !exists </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        
        <span class="cov0" title="0">return len(clicks), nil</span>
} </pre>
		
		<pre class="file" id="file13" style="display: none">package workers

import (
        "log"
        "github.com/axellelanca/urlshortener/internal/models"
        "github.com/axellelanca/urlshortener/internal/repository" 
)

func StartClickWorkers(workerCount int, clickEventsChan &lt;-chan models.ClickEvent, clickRepo repository.ClickRepository) <span class="cov0" title="0">{
        log.Printf("Starting %d click worker(s)...", workerCount)
        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                go clickWorker(clickEventsChan, clickRepo)
        }</span>
}

func clickWorker(clickEventsChan &lt;-chan models.ClickEvent, clickRepo repository.ClickRepository) <span class="cov0" title="0">{
        for event := range clickEventsChan </span><span class="cov0" title="0">{
                click := &amp;models.Click{
                        LinkID:    event.LinkID,
                        Timestamp: event.Timestamp,
                        UserAgent: event.UserAgent,
                        IPAddress: event.IPAddress,
                }                
                err := clickRepo.CreateClick(click)

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR: Failed to save click for LinkID %d (UserAgent: %s, IP: %s): %v",
                                event.LinkID, event.UserAgent, event.IPAddress, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Click recorded successfully for LinkID %d", event.LinkID)
                }</span>
        }
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "github.com/axellelanca/urlshortener/cmd"
        _ "github.com/axellelanca/urlshortener/cmd/cli"    // Importe le package 'cli' pour que ses init() soient exécutés
        _ "github.com/axellelanca/urlshortener/cmd/server" // Importe le package 'server' pour que ses init() soient exécutés
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
